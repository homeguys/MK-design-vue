import{_ as e,D as i,c as t,I as n,k as a,a as o,R as l,o as h}from"./chunks/framework.840RyDbT.js";const y=JSON.parse('{"title":"Taro里面滚动穿透的问题","description":"","frontmatter":{"editLink":true,"tags":["微信小程序","Taro","React","Hook"]},"headers":[],"relativePath":"zh-CN/tech/mobile/Taro中常用Hook的用法.md","filePath":"zh-CN/tech/mobile/Taro中常用Hook的用法.md","lastUpdated":1745984976000}'),r={name:"zh-CN/tech/mobile/Taro中常用Hook的用法.md"},p=a("h1",{id:"taro里面滚动穿透的问题",tabindex:"-1"},[o("Taro里面滚动穿透的问题 "),a("a",{class:"header-anchor vp-link",href:"#taro里面滚动穿透的问题","aria-label":'Permalink to "Taro里面滚动穿透的问题"'},"​")],-1),k=l(`<h2 id="关于-hook" tabindex="-1">关于 Hook <a class="header-anchor vp-link" href="#关于-hook" aria-label="Permalink to &quot;关于 Hook&quot;">​</a></h2><p>Hook 这个特性，是 React16.8 中新增的， 随着小程序框架 Taro 对 React 的支持， 让 Taro 也能开始使用， 甚至在 Taro3.0.0 开始，在底层 api 做了代理， 让 Hook 方法直接可以从 React 包中引用。 值得注意的是， Hook 的方法，只能在函数组件的主体内部调用。</p><h2 id="react-系的-hook" tabindex="-1">React 系的 Hook <a class="header-anchor vp-link" href="#react-系的-hook" aria-label="Permalink to &quot;React 系的 Hook&quot;">​</a></h2><h3 id="usestate" tabindex="-1">useState <a class="header-anchor vp-link" href="#usestate" aria-label="Permalink to &quot;useState&quot;">​</a></h3><p>由于函数式组件每次渲染都会执行一次函数， 那么函数内的变量是无法被保存住的。 所以如果想要将数据保存住的话， 需要使用这个 Hook，来将数据存储起来。</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用nCount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nCount&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nCount);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新Count</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="useeffect" tabindex="-1">useEffect <a class="header-anchor vp-link" href="#useeffect" aria-label="Permalink to &quot;useEffect&quot;">​</a></h3><p>这个 Hook 可谓是最常用的方法， 同时也是一个很危险的 Hook， 因为他可以模拟出来 3 种以类方式 React 的声明周期。</p><ul><li>可以模拟刚加载页面或者组件的声明周期 <strong>componentsDidMount</strong></li><li>可以模拟销毁页面或者组件的声明周期 <strong>componentsWillUnmount</strong></li><li>如果有依赖项 <strong>deps</strong> 的时候，那么就会监听 <strong>deps</strong> 中的数据，一旦数据有变化，则也会执行一次函数。</li></ul><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // componentsDidMount</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // componentsDidUpdate</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // componentsWillUnmount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [deps]);</span></span></code></pre></div><p>值得注意的是， 正因为会检测数值变化，就会执行一次函数， 所以如果在函数内又修改了该数值， 就会很容易产生死循环， 所以要谨慎的对书写函数内的逻辑。</p><p>那么，你也应该发现了， 这个函数也是一个闭包，内部的数据存在于独立的存储空间， 内部的数据永远都只会是第一次创建时候的数据。 如果需要跟外接数据同步，就需要将想同步的变量加入依赖 <strong>deps</strong> 中， 这样变量发生变化一次之后，内部闭包函数重新调用一次以更新数据。</p><h3 id="usememo" tabindex="-1">useMemo <a class="header-anchor vp-link" href="#usememo" aria-label="Permalink to &quot;useMemo&quot;">​</a></h3><h3 id="usecallback" tabindex="-1">useCallBack <a class="header-anchor vp-link" href="#usecallback" aria-label="Permalink to &quot;useCallBack&quot;">​</a></h3><h3 id="useref" tabindex="-1">useRef <a class="header-anchor vp-link" href="#useref" aria-label="Permalink to &quot;useRef&quot;">​</a></h3><p>将数据绑定到页面节点之上， 该数据的范围提升到一个页面级的纬度。 同时也可以帮助父组件拿到子组件属性。</p><h3 id="usecontext" tabindex="-1">useContext <a class="header-anchor vp-link" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h3><p>父组件的数据传递给子组件。 先要 createContext, 通过 Provider 标签传递 value， 在子组件里 useContext 拿到传递下来的 value。</p><hr><h2 id="taro-系-小程序专用-的-hook" tabindex="-1">Taro 系（小程序专用）的 Hook <a class="header-anchor vp-link" href="#taro-系-小程序专用-的-hook" aria-label="Permalink to &quot;Taro 系（小程序专用）的 Hook&quot;">​</a></h2><p>这些 Hook 对开发过小程序的小伙伴应该是非常友好的了。</p><h3 id="usedidshow" tabindex="-1">useDidShow <a class="header-anchor vp-link" href="#usedidshow" aria-label="Permalink to &quot;useDidShow&quot;">​</a></h3><p>页面再度激活， 返回或者切回前台的生命周期， 等同于 <strong>onShow(componentDidShow)</strong></p><h3 id="usedidhide" tabindex="-1">useDidHide <a class="header-anchor vp-link" href="#usedidhide" aria-label="Permalink to &quot;useDidHide&quot;">​</a></h3><p>切到后台，页面隐藏的生命周期， 等同于 <strong>onHide(componentDidHide)</strong></p><h3 id="usepulldownrefresh" tabindex="-1">usePullDownRefresh <a class="header-anchor vp-link" href="#usepulldownrefresh" aria-label="Permalink to &quot;usePullDownRefresh&quot;">​</a></h3><p>下拉刷新的生命周期， 等同于 <strong>onPullDownRefresh</strong></p><h3 id="usereachbottom" tabindex="-1">useReachBottom <a class="header-anchor vp-link" href="#usereachbottom" aria-label="Permalink to &quot;useReachBottom&quot;">​</a></h3><p>页面拉到底部的生命周期， 等同于 <strong>onReachBottom</strong></p><h3 id="usepagescroll" tabindex="-1">usePageScroll <a class="header-anchor vp-link" href="#usepagescroll" aria-label="Permalink to &quot;usePageScroll&quot;">​</a></h3><p>页面发生滚动的生命周期， 等同于 <strong>onPageScroll</strong></p><h3 id="useresize" tabindex="-1">useResize <a class="header-anchor vp-link" href="#useresize" aria-label="Permalink to &quot;useResize&quot;">​</a></h3><p>页面尺寸发生变化的生命周期， 等同于 <strong>onResize</strong></p><h3 id="useshareappmessage" tabindex="-1">useShareAppMessage <a class="header-anchor vp-link" href="#useshareappmessage" aria-label="Permalink to &quot;useShareAppMessage&quot;">​</a></h3><p>分享的生命周期， 等同于 <strong>onShareAppMessage</strong></p><h3 id="userouter" tabindex="-1">useRouter <a class="header-anchor vp-link" href="#userouter" aria-label="Permalink to &quot;useRouter&quot;">​</a></h3><p>获取路由信息。 等同于 <strong>getCurrentInstance().router</strong></p><h3 id="useready" tabindex="-1">useReady <a class="header-anchor vp-link" href="#useready" aria-label="Permalink to &quot;useReady&quot;">​</a></h3><p>页面节点加载完毕的生命周期， 等同于 <strong>onReady</strong></p><h2 id="自定义-hook" tabindex="-1">自定义 Hook <a class="header-anchor vp-link" href="#自定义-hook" aria-label="Permalink to &quot;自定义 Hook&quot;">​</a></h2><h3 id="usexxxx" tabindex="-1">useXXXX <a class="header-anchor vp-link" href="#usexxxx" aria-label="Permalink to &quot;useXXXX&quot;">​</a></h3><h2 id="后记" tabindex="-1">后记 <a class="header-anchor vp-link" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>其实，我自身对 Hook 的语法也是刚刚接触， 可能有些理解不是很深刻，也比较懵懂。 那么随着自身对这些 Hook 的理解， 我也会对这篇文章的内容不断更新。</p>`,43);function d(u,c,g,E,m,b){const s=i("VPAuthor");return h(),t("div",null,[p,n(s,{members:[{avatar:"https://img-nj.piesat.cn/static/Frontend/avatar/gj.png",name:"耿健"},{avatar:"https://img-nj.piesat.cn/static/Frontend/avatar/wl.png",name:"王磊"}]},null,8,["members"]),k])}const x=e(r,[["render",d]]);export{y as __pageData,x as default};
